#!/usr/bin/perl

# --- GCodeToolbox, written by Rene K. Mueller <spiritdude@gmail.com>
#
# License: GPLv2
#
$VERSION = '0.005';
$APPNAME = 'GCodeToolbox';
#
# History:
# 2013/02/09: 0.005: proper header and trailer if objects are concated
# 2013/02/09: 0.004: proper movement at wrapping at concating (inserting G1 moves)
# 2013/02/09: 0.003: optional left-to-right to right-to-left swinging
# 2013/02/09: 0.002: passing slicer arguments via --slicer.<key>=<value>
# 2013/02/08: 0.001: start, info and concat works

use Math::Trig;
use POSIX;

my(%arg);

my $cmd;
my $multiply = 1;

foreach(@ARGV) {
   $arg{$1} = $2, next if(/^\-\-([^\s=]+)=(\S+)/);
   $arg{$1}++, next if(/^\-\-([^\s=]+)/||/^\-(\S+)/);
   $cmd = $_, next unless($cmd);
   $multiply = $1, next if(/^(\d+)x$/);
   if(-e $_) {
      my $f = $_;
      push(@f,$f) foreach(1..$multiply);
      $multiply = 1;
      next;
   } else {
      print "ERROR: don't know what to do with '$_'\n";
      help();
   }
}

my $verbose = $arg{v};

$arg{objectSpacing} = 3 unless(defined $arg{objectSpacing});
$arg{slicer} = 'slic3r' unless(defined $arg{slicer});
#$arg{swinging} = 'on' unless(defined $arg{swinging});

$arg{printerX} = 200;
$arg{printerY} = 200;
$arg{printerZ} = 200;
$arg{printerMargin} = 3;

if($arg{printer}&&open(F,$arg{printer})) {
   print STDERR "printer: $arg{printer} profile\n";
   while(<F>) {
      chop;
      next if(/^\s*#/);
      if(/^\s*([^\s:=]+)\s*[:=]\s*(\S.+)\s*$/) {
         my($k,$v) = ($1,$2);
         $k =~ s/(.)/uc $1/e;
         $arg{"printer$k"} = $v;
      } 
   }
   close(F);
}

help() if($#f<0); # -- nothing to do
process($cmd,@f);

sub process {
   my($cmd,@f) = @_;

   print "=== $cmd on @f\n" if($verbose);

   if($cmd eq 'cat'||$cmd eq 'concat') {
      concatObjects(@f);
   
   } elsif($cmd eq 'slice') {
      foreach my $f (@f) {
         print "=== slicing: $f (with $arg{slicer})\n";
         my(@sargs);
         foreach my $k (sort keys %arg) {
            push(@sargs,"--$1=".$arg{$k}) if($k=~/^slicer\.(\S+)/);
         }
         print "execute $arg{slicer} @sargs $f\n" if($verbose);
         print `$arg{slicer} @sargs $f`;
      }
      
   } elsif($cmd eq 'info') {
      foreach my $f (@f) {
         my($i) = parseGCode($f);
         print "=== $f:\n";
         foreach my $k (sort keys %${i}) {
            next if($k=~/\.unit$/);
            #print sprintf("  %40s: $i->{$k}",$k);
            print "\t$k: ";
            if(ref $i->{$k} eq 'ARRAY') {
               print "array: ",@{$i->{$k}}+1," entries";
            } else {
               print $i->{$k};
               print " ".$i->{"$k.unit"} if($i->{"$k.unit"});
            }
            print "\n";
         }
      }
   } else {
      print STDERR "ERROR: unknown command '$cmd'\n";
      help();
   }
}

sub help {
   print STDERR join("\n",
      "$APPNAME $VERSION:",
      "\t-h or --help      this help",
      "\t-v                increase verbosity", 
      "\t--slicer=cmd      define slicer (default: $arg{slicer})",
      "\t--slicer.[arg]=x  define slicer arguments passed on slicer (e.g. --slicer.skirts=0)",
      "\t--printer=file    reference printer profile",
      "\t--printerX=x      define build width (default: $arg{printerX}) [mm]",
      "\t--printerY=y      define build depth (default: $arg{printerY}) [mm]",
      "\t--printerZ=z      define build height (default: $arg{printerZ}) [mm]",
      "\t--printerMargin=m define margin to perimeter of platform (default: $arg{printerMargin}) [mm]",
      #"\t--cols=c          define columns when concating (default: $arg{cols}) [mm]",
      #"\t--swinging        enable swinging left-to-right to right-to-left when concating (default: $arg{swinging})",
      "\t--objectSpacing=x define distance between items when concating (default: $arg{objectSpacing}) [mm]",
      "\tinfo [file1]...   provide info on gcode files (default)",
      "\tslice [file1]...  slice .stl files to .gcode",
      "\tcat [file1]...    concate multiple .gcode files (stdout)",
      ),"\n\n";
   exit 1;
}

sub parseGCode {
   my($f) = @_;
   my %g;
   my %h;
   
   $g{filename} = $f;
   foreach my $a (qw(x y z)) {
      foreach my $f (qw(Min Max Movement)) {
         $g{$a.$f.'.unit'} = 'mm';
      }
   }
   $g{'filamentLength.unit'} = 'mm';
   $g{'filamentVolume.unit'} = 'mm3';

   open(F,$f);
   while(<F>) {
      chop; my($l) = $_;

      $g{codeLines}++;
      print "$f: >>> $_\n" if($verbose);

      $g{"commentInfo.$1"} = $2 if(/^\s*;\s+(\S+)\s*[=:]\s*(.+)\s*$/);    # -- slic3r gives some useful metadata in the comments
      $g{comments}++, next if(/^\s*;/);

      my(@d) = split(/\s+/,$l);        # -- we decompose the line
      foreach(@d) {
         print "\t\t'$_'\n" if($verbose>1);
         if(/(M\d+)/) {
            my $c = $1;
            $g{"operations.$c.count"}++;
            $h{object} = 2 if($c eq 'M107'&&$h{object}==1);
            $h{field} = 'extruderTemperature' if($c eq 'M104');
            
         } elsif(/S([\d\.\-]+)/) {
            my($v) = $1;
            #$g{"operations.S$v.count"}++;
            $g{$h{field}."Min"} = $v if(!defined $g{$h{field}."Min"}||$g{$h{field}."Min"}>$v);
            $g{$h{field}."Max"} = $v if(!defined $g{$h{field}."Max"}||$g{$h{field}."Max"}<$v);
            push(@{$g{$h{field}}},$v);
            $h{"$h{field}Sum"} += $v; $h{"$h{field}Count"}++;
            $g{"$h{field}Average"} = $h{"$h{field}Sum"}/$h{"$h{field}Count"};

         } elsif(/(G\d+)/) {
            my $c = $1;
            $g{"operations.$c.count"}++;
            $h{object} = 1 if($c eq 'G1');
            #$h{object} = 1 if($c eq 'G92');
            #$h{object} = 1 if($c eq 'G28'&&$h{object}==0);
            $h{object} = 2 if($c eq 'G28'&&$h{object}==1);
            
         } elsif(/([XYZ])([\-\d\.]+)/) {
            my($a,$v) = ($1,$2);
            my($f) = 'movement'.$a;
            $g{$f.'Min'} = $v if(!defined $g{$f.'Min'}||$g{$f.'Min'}>$v);
            $g{$f.'Max'} = $v if(!defined $g{$f.'Max'}||$g{$f.'Max'}<$v);
            $g{$f.'Total'} += abs($v-$h{$a.'Position'});
            $g{$f.'Count'}++;
            $h{$a.'Position'} = $v;
            $h{object} = 1 if($a eq 'Z'&&$v==0);
         
         } elsif(/F([\-\d\.]+)/) {
            my($v) = $1;
            my($f) = 'feedrate';
            $g{$f.'Min'} = $v if(!defined $g{$f.'Min'}||$g{$f.'Min'}>$v);
            $g{$f.'Max'} = $v if(!defined $g{$f.'Max'}||$g{$f.'Max'}<$v);
            
         } elsif(/E([\-\d\.]+)/) {
            my($v) = $1;

            $g{filamentLength} += $v;
            $g{filamentVolume} += ($v>0?1:-1)*sq($g{"commentInfo.filament_diameter"}/2)*pi*$v if($g{"commentInfo.filament_diameter"});
            
            if($v>0) {                       # -- actually printing out
               foreach my $a (qw(X Y Z)) {   # -- we calculate the actual size of the object as printed
                  my $f = "object".$a;
                  my $v = $h{$a.'Position'};
                  $g{$f.'Min'} = $v if(!defined $g{$f.'Min'}||$g{$f.'Min'}>$v);
                  $g{$f.'Max'} = $v if(!defined $g{$f.'Max'}||$g{$f.'Max'}<$v);
               }
               $h{object} = 1;
            }
            
         } elsif($_ eq ';') {
            last;
         }
      }
      if($h{object}==0) {
         ;  # -- head
      } elsif($h{object}==1) {
         push(@{$g{codeObject}},$l);
      } else {
         ;  # -- tail
      }
      push(@{$g{codeRaw}},$l);
   }
   close(F);

   $g{objectX} = $g{objectXMax} - $g{objectXMin};
   $g{objectY} = $g{objectYMax} - $g{objectYMin};
   $g{objectZ} = $g{objectZMax} - $g{objectZMin};

   return \%g;
}

sub concatObjects {
   my(@f) = @_;
   my($xoff,$yoff,$ymax,$zmax) = ( 0,0,0,0 );
   my($n,$xdir);
   my($t) = time();
   
   $xoff = $arg{printerMargin};
   $yoff = $arg{printerMargin};
   $xdir = 1;

   print "; generated by $APPNAME $VERSION\n";
   print "; created: ",prettyDate($t)," ($t)\n";
   print "; command: concateObjects(",join(",",@f),")\n";
   foreach (sort keys %arg) {
      print ";    $_: $arg{$_}\n";
   }
   
   foreach my $f (@f) {
      my $wrapping;
      
      my($i) = parseGCode($f);
      
      if($xdir<0) {
         $xoff += $xdir*($i->{objectX}+$arg{objectSpacing});
      }
      $n++;
      if($xdir>0) {
         if($xoff+$i->{objectX}+$arg{printerMargin}>=$arg{printerX}) {  
            if($arg{swinging}) {     # --- swinging left-to-right and right-to-left
               $xoff = $arg{printerX}-($arg{printerMargin}+$i->{objectX});
               $xdir *= -1;
            } else {
               $xoff = $arg{printerMargin};
            }
            $yoff = $ymax+$arg{objectSpacing};
            #print STDERR "wrapping\n";
            print "G1 Y$yoff ; wrapping \n";    # -- let's make sure we don't run into already printed objects
            print "G1 X$yoff\n";
            $wrapping++;
         }
      } else {
         if($xoff<=0) {  
            $xoff = $arg{printerMargin};
            $yoff = $ymax+$arg{objectSpacing};
            $xdir *= -1;
            #print STDERR "wrapping\n";
            print "G1 Y$yoff ; wrapping\n";    # -- let's make sure we don't run into already printed objects
            print "G1 X$yoff\n";
            $wrapping++;
         }
      }
      if($yoff+$i->{objectY}+$arg{printerMargin}>=$arg{printerY}) {
         print STDERR "ERROR: object #$n, $f doesn't fit on plate anymore ($arg{printerX}x$arg{printerY}), disregarded\n";
         next;
      }

      print STDERR "place $f (#$n of ",($#f+1),") $i->{objectX}x$i->{objectY}+$xoff+$yoff (",($xdir>0?'left-to-right':'right-to-left'),")\n";

      unless($wrapped) {
         print "G1 X$xoff ; move away from printed object\n";
         print "G1 Y$yoff ; to next origin of next object\n";
      }
      reoriginObject($i,$xoff,$yoff,'keep');
      print "; start of $f (#$n of ",($#f+1),")\n";

      $zmax = $i->{objectZ} if($zmax<$i->{objectZ});

      printObject($i);
      print "; end of $f (#$n of ",($#f+1),")\n";
      
      $ymax = $yoff+$i->{objectY} if($ymax<$yoff+$i->{objectY});
      if($xdir>0) { 
         $xoff += $xdir*($i->{objectX}+$arg{objectSpacing});
      }
   }
   $zmax += 3;    # -- give extra 3mm to be sure
   
   print join("\n",     # -- the trailer
      "M107    ; fan off",
      "M104 S0 ; turn off temperature",
      "G1 Z$zmax ; move up to higest Z",
      "G28 X0  ; home X axis",
      "M84     ; disable motors"),"\n";
   print "; end of concateObjects()\n";
}
      
sub reoriginObject {
   my($i,$x,$y,$z) = @_;
   my(@n);
   foreach(@{$i->{codeObject}}) {
      my(@d) = split(/\s+/);
      my(@dn);
      foreach(@d) {
         if(/([XYZ])([\d\.]+)/) {
            my($a,$v) = ($1,$2);
            my($fmin) = "object".$a."Min";
            my($fmax) = "object".$a."Max";
            $v = $v-$i->{$fmin};
            if($x ne 'keep') { $v += $x if($a eq 'X'); }
            if($y ne 'keep') { $v += $y if($a eq 'Y'); }
            if($z ne 'keep') { $v += $z if($a eq 'Z'); }
            push(@dn,$a.$v);
         } else {
            push(@dn,$_);
         }
      }
      push(@n,join(" ",@dn));
   }
   @{$i->{codeObject}} = @n;
}

sub printObject {
   my($i) = @_;
   foreach(@{$i->{codeObject}}) {
      print "$_\n";
   }
}

sub sq {
   return $_[0]*$_[0];
}

sub prettyDate {
   @_ = localtime($_[0]);
   return sprintf("%04d/%02d/%02d %02d:%02d:%02d %s",$_[5]+1900,$_[4]+1,$_[3],$_[2],$_[1],$_[0],strftime('%Z',@_));
}

